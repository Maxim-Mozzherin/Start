// Логические операции
// Умножение
int q1 = 2; //010
int w1 = 5;//101
Console.WriteLine(q1 & w1); // выведет 0

int x2 = 4; //100
int y2 = 5; //101
Console.WriteLine(x2 & y2); // выведет 4

int x1 = 3; //011
int y1 = 5; //101
int z1 = 1; //001
Console.WriteLine(x1 & y1 & z1); // 1
/*
В первом случае у нас два числа 2 и 5. 2 в двоичном виде представляет число 010, а 5 - 101. Поразрядно умножим числа (0*1, 1*0, 0*1) и в итоге получим 000.

Во втором случае у нас вместо двойки число 4, у которого в первом разряде 1, так же как и у числа 5, поэтому в итоге получим (1*1, 0*0, 0 *1) = 100,
то есть число 4 в десятичном формате.
*/

int x3 = 2; //010
int y3 = 5;//101
Console.WriteLine(x3 | y3); // выведет 7 - 111
int x4 = 4; //100
int y4 = 5;//101
Console.WriteLine(x4 | y4); // выведет 5 - 101

/*
| (логическое сложение)

Похоже на логическое умножение, операция также производится по двоичным разрядам,
но теперь возвращается единица, если хотя бы у одного числа в данном разряде имеется единица. 
*/
// XOR
int x = 45; // Значение, которое надо зашифровать - в двоичной форме 101101
int key = 102; //Пусть это будет ключ - в двоичной форме             1100110

int encrypt = x ^ key; //Результатом будет число                   1001011 или 75
Console.WriteLine($"Зашифрованное число: {encrypt}");

int decrypt = encrypt ^ key; // Результатом будет исходное число 45
Console.WriteLine($"Расшифрованное число: {decrypt}");
//!!!!!!!!!!!!!! Интересно: Таким образом можно обменять 2 положительных числа без использования доп переменной
/*
int a = 9;  // 1001 
int b = 5;  // 0101
  
a = a ^ b;  // a = 1001 ^ 0101 = 1100 = 12
b = a ^ b;  // b = 12 ^ 5 = 1100 ^ 0101 = 1001 = 9
a = a ^ b;  // a = 12 ^ 9 = 1100 ^ 1001 = 0101 = 5
 
Console.WriteLine($"a: {a}") ;  // 5
Console.WriteLine($"b: {b}") ;  // 9 
 */
// Инверсия
int x7 = 12;                 // 00001100
Console.WriteLine(~x7);      // 11110011   или -13

// Представление отрицательных чисел?
int x8 = 12;
int y8 = ~x8;
y8 += 1;
Console.WriteLine(y8);   // -12



/*Опреации сдвига
Операции сдвига
Операции сдвига также производятся над разрядами чисел. Сдвиг может происходить вправо и влево.

x<<y - сдвигает число x влево на y разрядов. Например, 4<<1 сдвигает число 4 (которое в двоичном представлении 100) на один разряд влево,
то есть в итоге получается 1000 или число 8 в десятичном представлении.

x>>y - сдвигает число x вправо на y разрядов. Например, 16>>1 сдвигает число 16 (которое в двоичном представлении 10000) на один разряд вправо,
то есть в итоге получается 1000 или число 8 в десятичном представлении.

Таким образом, если исходное число, которое надо сдвинуть в ту или другую строну, делится на два, то фактически получается умножение или деление на два.
Поэтому подобную операцию можно использовать вместо непосредственного умножения или деления на два. Например:

int a = 16; // в двоичной форме 10000
int b = 2; // в двоичной форме
int c = a << b; // Сдвиг числа 10000 влево на 2 разряда, равно 1000000 или 64 в десятичной системе
 
Console.WriteLine($"Зашифрованное число: {c}") ;    // 64
 
int d = a >> b; // Сдвиг числа 10000 вправо на 2 разряда, равно 100 или 4 в десятичной системе
Console.WriteLine($"Зашифрованное число: {d}");     // 4

int a = 22; // в двоичной форме 10110
int b = 2; // в двоичной форме
int c = a << b; // Сдвиг числа 10110 влево на 2 разряда, равно 1011000 или 88 в десятичной системе
 
Console.WriteLine($"Зашифрованное число: {c}") ;    // 88
 
int d = a >> b; // Сдвиг числа 10110 вправо на 2 разряда, равно 101 или 5 в десятичной системе
Console.WriteLine($"Зашифрованное число: {d}");     // 5
*/